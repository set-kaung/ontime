// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: service_request.sql

package repository

import (
	"context"
	"time"
)

const getActiveUserServiceRequests = `-- name: GetActiveUserServiceRequests :many
SELECT
    sr.id, sr.listing_id, sr.requester_id, sr.provider_id, sr.status_detail, sr.activity, sr.created_at, sr.updated_at, sr.token_reward,
    requester.full_name AS requester_name,
    provider.full_name  AS provider_name,
    l.title
FROM
    service_request sr
JOIN "user" requester ON sr.requester_id = requester.id
JOIN "user" provider  ON sr.provider_id = provider.id
JOIN service_listing l on sr.listing_id  = l.id
WHERE
    (sr.provider_id = $1 OR sr.requester_id = $1)
    AND sr.activity = 'active'
`

type GetActiveUserServiceRequestsRow struct {
	ID            int32                `json:"id"`
	ListingID     int32                `json:"listing_id"`
	RequesterID   string               `json:"requester_id"`
	ProviderID    string               `json:"provider_id"`
	StatusDetail  ServiceRequestStatus `json:"status_detail"`
	Activity      ServiceActivity      `json:"activity"`
	CreatedAt     time.Time            `json:"created_at"`
	UpdatedAt     time.Time            `json:"updated_at"`
	TokenReward   int32                `json:"token_reward"`
	RequesterName string               `json:"requester_name"`
	ProviderName  string               `json:"provider_name"`
	Title         string               `json:"title"`
}

func (q *Queries) GetActiveUserServiceRequests(ctx context.Context, providerID string) ([]GetActiveUserServiceRequestsRow, error) {
	rows, err := q.db.Query(ctx, getActiveUserServiceRequests, providerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveUserServiceRequestsRow
	for rows.Next() {
		var i GetActiveUserServiceRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.RequesterID,
			&i.ProviderID,
			&i.StatusDetail,
			&i.Activity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TokenReward,
			&i.RequesterName,
			&i.ProviderName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserRequests = `-- name: GetAllUserRequests :many
SELECT
    sr.id, sr.listing_id, sr.requester_id, sr.provider_id, sr.status_detail, sr.activity, sr.created_at, sr.updated_at, sr.token_reward,
    requester.full_name AS requester_name,
    provider.full_name  AS provider_name,
    l.title
FROM
    service_request sr
JOIN "user" requester ON sr.requester_id = requester.id
JOIN "user" provider  ON sr.provider_id = provider.id
JOIN service_listing l on sr.listing_id  = l.id
WHERE
    (sr.provider_id = $1 OR sr.requester_id = $1)
`

type GetAllUserRequestsRow struct {
	ID            int32                `json:"id"`
	ListingID     int32                `json:"listing_id"`
	RequesterID   string               `json:"requester_id"`
	ProviderID    string               `json:"provider_id"`
	StatusDetail  ServiceRequestStatus `json:"status_detail"`
	Activity      ServiceActivity      `json:"activity"`
	CreatedAt     time.Time            `json:"created_at"`
	UpdatedAt     time.Time            `json:"updated_at"`
	TokenReward   int32                `json:"token_reward"`
	RequesterName string               `json:"requester_name"`
	ProviderName  string               `json:"provider_name"`
	Title         string               `json:"title"`
}

func (q *Queries) GetAllUserRequests(ctx context.Context, userID string) ([]GetAllUserRequestsRow, error) {
	rows, err := q.db.Query(ctx, getAllUserRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserRequestsRow
	for rows.Next() {
		var i GetAllUserRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.RequesterID,
			&i.ProviderID,
			&i.StatusDetail,
			&i.Activity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TokenReward,
			&i.RequesterName,
			&i.ProviderName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByID = `-- name: GetRequestByID :one
SELECT
  sr.id AS sr_id,
  sr.listing_id AS sr_listing_id,
  sr.status_detail AS sr_status_detail,
  sr.activity AS sr_activity,
  sr.created_at AS sr_created_at,
  sr.updated_at AS sr_updated_at,
  sr.token_reward AS sr_token_reward,

  sl.id AS sl_id,
  sl.title AS sl_title,
  sl.description AS sl_description,
  sl.posted_by AS sl_posted_by,
  sl.posted_at AS sl_posted_at,
  sl.category AS sl_category,

  ru.id AS requester_id,
  ru.full_name AS requester_full_name,
  ru.joined_at AS requester_joined_at,

  pu.id AS provider_id,
  pu.full_name AS provider_full_name,
  pu.joined_at AS provider_joined_at,

  COALESCE(sc.requester_completed,false),
  COALESCE(sc.provider_completed,false),
  COALESCE(
    json_agg(
      json_build_object(
        'event_id', e.id,
        'event_time', e.created_at,
        'event_description', e.description,
        'event_owner', n.action_user_id
      )
      ORDER BY e.created_at
    ) FILTER (WHERE e.id IS NOT NULL),
    '[]'::json
  )::json AS events
FROM service_request sr
JOIN service_listing sl ON sr.listing_id = sl.id
JOIN "user" ru ON sr.requester_id = ru.id
JOIN "user" pu ON sr.provider_id = pu.id
LEFT JOIN service_request_completion sc ON sr.id = sc.request_id
LEFT JOIN events e ON e.target_id = sr.id
LEFT JOIN notification n
ON n.event_id = e.id
WHERE sr.id = $1
GROUP BY
  sr.id, sl.id, ru.id, pu.id, sc.requester_completed, sc.provider_completed
`

type GetRequestByIDRow struct {
	SrID               int32                `json:"sr_id"`
	SrListingID        int32                `json:"sr_listing_id"`
	SrStatusDetail     ServiceRequestStatus `json:"sr_status_detail"`
	SrActivity         ServiceActivity      `json:"sr_activity"`
	SrCreatedAt        time.Time            `json:"sr_created_at"`
	SrUpdatedAt        time.Time            `json:"sr_updated_at"`
	SrTokenReward      int32                `json:"sr_token_reward"`
	SlID               int32                `json:"sl_id"`
	SlTitle            string               `json:"sl_title"`
	SlDescription      string               `json:"sl_description"`
	SlPostedBy         string               `json:"sl_posted_by"`
	SlPostedAt         time.Time            `json:"sl_posted_at"`
	SlCategory         string               `json:"sl_category"`
	RequesterID        string               `json:"requester_id"`
	RequesterFullName  string               `json:"requester_full_name"`
	RequesterJoinedAt  time.Time            `json:"requester_joined_at"`
	ProviderID         string               `json:"provider_id"`
	ProviderFullName   string               `json:"provider_full_name"`
	ProviderJoinedAt   time.Time            `json:"provider_joined_at"`
	RequesterCompleted bool                 `json:"requester_completed"`
	ProviderCompleted  bool                 `json:"provider_completed"`
	Events             []byte               `json:"events"`
}

func (q *Queries) GetRequestByID(ctx context.Context, id int32) (GetRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getRequestByID, id)
	var i GetRequestByIDRow
	err := row.Scan(
		&i.SrID,
		&i.SrListingID,
		&i.SrStatusDetail,
		&i.SrActivity,
		&i.SrCreatedAt,
		&i.SrUpdatedAt,
		&i.SrTokenReward,
		&i.SlID,
		&i.SlTitle,
		&i.SlDescription,
		&i.SlPostedBy,
		&i.SlPostedAt,
		&i.SlCategory,
		&i.RequesterID,
		&i.RequesterFullName,
		&i.RequesterJoinedAt,
		&i.ProviderID,
		&i.ProviderFullName,
		&i.ProviderJoinedAt,
		&i.RequesterCompleted,
		&i.ProviderCompleted,
		&i.Events,
	)
	return i, err
}

const getRequestReport = `-- name: GetRequestReport :one
SELECT id, reporter_id, request_id, ticket_id, created_at, status FROM request_report
WHERE request_id = $1 AND reporter_id = $2
`

type GetRequestReportParams struct {
	RequestID  int32  `json:"request_id"`
	ReporterID string `json:"reporter_id"`
}

func (q *Queries) GetRequestReport(ctx context.Context, arg GetRequestReportParams) (RequestReport, error) {
	row := q.db.QueryRow(ctx, getRequestReport, arg.RequestID, arg.ReporterID)
	var i RequestReport
	err := row.Scan(
		&i.ID,
		&i.ReporterID,
		&i.RequestID,
		&i.TicketID,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const getServiceRequestCompletion = `-- name: GetServiceRequestCompletion :one
SELECT id, request_id, requester_completed, provider_completed, is_active FROM service_request_completion
WHERE request_id = $1
`

func (q *Queries) GetServiceRequestCompletion(ctx context.Context, requestID int32) (ServiceRequestCompletion, error) {
	row := q.db.QueryRow(ctx, getServiceRequestCompletion, requestID)
	var i ServiceRequestCompletion
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.RequesterCompleted,
		&i.ProviderCompleted,
		&i.IsActive,
	)
	return i, err
}

const insertPendingServiceRequest = `-- name: InsertPendingServiceRequest :one
INSERT INTO service_request (listing_id,requester_id,provider_id,status_detail,activity,created_at,updated_at,token_reward)
SELECT
    $1,
    $2,
    sl.posted_by,
    'pending', 'active', NOW(),NOW(),sl.token_reward
FROM service_listing sl
WHERE sl.id = $1 AND sl.posted_by != $2
RETURNING id
`

type InsertPendingServiceRequestParams struct {
	ListingID   int32  `json:"listing_id"`
	RequesterID string `json:"requester_id"`
}

func (q *Queries) InsertPendingServiceRequest(ctx context.Context, arg InsertPendingServiceRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertPendingServiceRequest, arg.ListingID, arg.RequesterID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertRequestReport = `-- name: InsertRequestReport :one
INSERT INTO request_report (reporter_id, request_id, ticket_id, created_at,"status")
VALUES ($1, $2, '', NOW(),"ongoing")
RETURNING id, created_at
`

type InsertRequestReportParams struct {
	ReporterID string `json:"reporter_id"`
	RequestID  int32  `json:"request_id"`
}

type InsertRequestReportRow struct {
	ID        int32     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) InsertRequestReport(ctx context.Context, arg InsertRequestReportParams) (InsertRequestReportRow, error) {
	row := q.db.QueryRow(ctx, insertRequestReport, arg.ReporterID, arg.RequestID)
	var i InsertRequestReportRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const insertServiceRequestCompletion = `-- name: InsertServiceRequestCompletion :exec
INSERT INTO service_request_completion (request_id,requester_completed,provider_completed,is_active)
VALUES ($1,false,false,true)
`

func (q *Queries) InsertServiceRequestCompletion(ctx context.Context, requestID int32) error {
	_, err := q.db.Exec(ctx, insertServiceRequestCompletion, requestID)
	return err
}

const updateExpiredRequest = `-- name: UpdateExpiredRequest :many
UPDATE service_request AS sr
SET status_detail = 'expired'
FROM service_listing AS sl
WHERE sl.id = sr.listing_id
  AND NOW() - sr.updated_at > INTERVAL '36 hour'
RETURNING
  sr.id,
  sr.listing_id,
  sr.status_detail,
  sr.updated_at,
  sr.requester_id,
  sr.provider_id,
  sr.token_reward,
  sl.title AS listing_title
`

type UpdateExpiredRequestRow struct {
	ID           int32                `json:"id"`
	ListingID    int32                `json:"listing_id"`
	StatusDetail ServiceRequestStatus `json:"status_detail"`
	UpdatedAt    time.Time            `json:"updated_at"`
	RequesterID  string               `json:"requester_id"`
	ProviderID   string               `json:"provider_id"`
	TokenReward  int32                `json:"token_reward"`
	ListingTitle string               `json:"listing_title"`
}

func (q *Queries) UpdateExpiredRequest(ctx context.Context) ([]UpdateExpiredRequestRow, error) {
	rows, err := q.db.Query(ctx, updateExpiredRequest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdateExpiredRequestRow
	for rows.Next() {
		var i UpdateExpiredRequestRow
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.StatusDetail,
			&i.UpdatedAt,
			&i.RequesterID,
			&i.ProviderID,
			&i.TokenReward,
			&i.ListingTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestReportWithTicketID = `-- name: UpdateRequestReportWithTicketID :one
UPDATE request_report
SET ticket_id = $1
WHERE id = $2
RETURNING ticket_id
`

type UpdateRequestReportWithTicketIDParams struct {
	TicketID string `json:"ticket_id"`
	ID       int32  `json:"id"`
}

func (q *Queries) UpdateRequestReportWithTicketID(ctx context.Context, arg UpdateRequestReportWithTicketIDParams) (string, error) {
	row := q.db.QueryRow(ctx, updateRequestReportWithTicketID, arg.TicketID, arg.ID)
	var ticket_id string
	err := row.Scan(&ticket_id)
	return ticket_id, err
}

const updateServiceRequest = `-- name: UpdateServiceRequest :one
UPDATE service_request
SET status_detail = $1, activity = $2, updated_at = NOW()
WHERE id = $3
RETURNING id
`

type UpdateServiceRequestParams struct {
	StatusDetail ServiceRequestStatus `json:"status_detail"`
	Activity     ServiceActivity      `json:"activity"`
	ID           int32                `json:"id"`
}

func (q *Queries) UpdateServiceRequest(ctx context.Context, arg UpdateServiceRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateServiceRequest, arg.StatusDetail, arg.Activity, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateServiceRequestCompletion = `-- name: UpdateServiceRequestCompletion :exec
UPDATE service_request_completion
SET requester_completed = $1, provider_completed = $2, is_active = $3
WHERE request_id = $4
`

type UpdateServiceRequestCompletionParams struct {
	RequesterCompleted bool  `json:"requester_completed"`
	ProviderCompleted  bool  `json:"provider_completed"`
	IsActive           bool  `json:"is_active"`
	RequestID          int32 `json:"request_id"`
}

func (q *Queries) UpdateServiceRequestCompletion(ctx context.Context, arg UpdateServiceRequestCompletionParams) error {
	_, err := q.db.Exec(ctx, updateServiceRequestCompletion,
		arg.RequesterCompleted,
		arg.ProviderCompleted,
		arg.IsActive,
		arg.RequestID,
	)
	return err
}
