// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTokens = `-- name: AddTokens :exec
UPDATE users
SET token_balance = token_balance + $1
WHERE id = $2
`

type AddTokensParams struct {
	TokenBalance int32  `json:"token_balance"`
	ID           string `json:"id"`
}

func (q *Queries) AddTokens(ctx context.Context, arg AddTokensParams) error {
	_, err := q.db.Exec(ctx, addTokens, arg.TokenBalance, arg.ID)
	return err
}

const deductRewardTokens = `-- name: DeductRewardTokens :exec
UPDATE users
SET token_balance = token_balance - r.cost
FROM rewards r
WHERE users.id = $1 AND r.id = $2 AND users.token_balance >= r.cost
`

type DeductRewardTokensParams struct {
	UserID   string `json:"user_id"`
	RewardID int32  `json:"reward_id"`
}

func (q *Queries) DeductRewardTokens(ctx context.Context, arg DeductRewardTokensParams) error {
	_, err := q.db.Exec(ctx, deductRewardTokens, arg.UserID, arg.RewardID)
	return err
}

const deductTokens = `-- name: DeductTokens :execrows
UPDATE users
SET token_balance = token_balance - s.token_reward
FROM service_listings s
WHERE users.id = $1
  AND s.id = $2
  AND users.token_balance >= s.token_reward
`

type DeductTokensParams struct {
	UserID    string `json:"user_id"`
	ListingID int32  `json:"listing_id"`
}

func (q *Queries) DeductTokens(ctx context.Context, arg DeductTokensParams) (int64, error) {
	result, err := q.db.Exec(ctx, deductTokens, arg.UserID, arg.ListingID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteUser = `-- name: DeleteUser :execresult
DELETE FROM users where id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteUser, id)
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    u.id, u.phone, u.token_balance, u.status, u.address_line_1, u.address_line_2, u.city, u.state_province, u.zip_postal_code, u.country, u.joined_at, u.email, u.full_name,
    COALESCE(sp.requested_count, 0) AS services_received,
    COALESCE(sp.provided_count, 0) AS services_provided,
    r.total_ratings,
    r.rating_count
FROM users u
LEFT JOIN (
    SELECT
      user_id,
      COUNT(*) FILTER (WHERE role = 'requester') AS requested_count,
      COUNT(*) FILTER (WHERE role = 'provider') AS provided_count
    FROM (
      SELECT requester_id AS user_id, 'requester' AS role
      FROM service_requests
      UNION ALL
      SELECT provider_id AS user_id, 'provider' AS role
      FROM service_requests
    ) combined
    GROUP BY user_id
) sp ON u.id = sp.user_id
LEFT JOIN ratings r
ON r.user_id = u.id
WHERE u.id = $1
`

type GetUserByIDRow struct {
	ID               string        `json:"id"`
	Phone            string        `json:"phone"`
	TokenBalance     int32         `json:"token_balance"`
	Status           AccountStatus `json:"status"`
	AddressLine1     string        `json:"address_line_1"`
	AddressLine2     string        `json:"address_line_2"`
	City             string        `json:"city"`
	StateProvince    string        `json:"state_province"`
	ZipPostalCode    string        `json:"zip_postal_code"`
	Country          string        `json:"country"`
	JoinedAt         time.Time     `json:"joined_at"`
	Email            bool          `json:"email"`
	FullName         string        `json:"full_name"`
	ServicesReceived int64         `json:"services_received"`
	ServicesProvided int64         `json:"services_provided"`
	TotalRatings     pgtype.Int4   `json:"total_ratings"`
	RatingCount      pgtype.Int4   `json:"rating_count"`
}

func (q *Queries) GetUserByID(ctx context.Context, id string) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.TokenBalance,
		&i.Status,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.StateProvince,
		&i.ZipPostalCode,
		&i.Country,
		&i.JoinedAt,
		&i.Email,
		&i.FullName,
		&i.ServicesReceived,
		&i.ServicesProvided,
		&i.TotalRatings,
		&i.RatingCount,
	)
	return i, err
}

const getUserTokenBalance = `-- name: GetUserTokenBalance :one
SELECT token_balance FROM users
WHERE id = $1
`

func (q *Queries) GetUserTokenBalance(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRow(ctx, getUserTokenBalance, id)
	var token_balance int32
	err := row.Scan(&token_balance)
	return token_balance, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO users (
    id,
    full_name,
    phone,
    token_balance,
    status,
    address_line_1,
    address_line_2,
    city,
    state_province,
    zip_postal_code,
    country,
    joined_at,
    email
)
VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10,
  $11, NOW(), $12
)
RETURNING id
`

type InsertUserParams struct {
	ID            string        `json:"id"`
	FullName      string        `json:"full_name"`
	Phone         string        `json:"phone"`
	TokenBalance  int32         `json:"token_balance"`
	Status        AccountStatus `json:"status"`
	AddressLine1  string        `json:"address_line_1"`
	AddressLine2  string        `json:"address_line_2"`
	City          string        `json:"city"`
	StateProvince string        `json:"state_province"`
	ZipPostalCode string        `json:"zip_postal_code"`
	Country       string        `json:"country"`
	Email         bool          `json:"email"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (string, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.FullName,
		arg.Phone,
		arg.TokenBalance,
		arg.Status,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.StateProvince,
		arg.ZipPostalCode,
		arg.Country,
		arg.Email,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateUser = `-- name: UpdateUser :execresult
UPDATE users
SET full_name = $1, phone = $2, address_line_1 = $3, address_line_2 = $4, city = $5, state_province = $6, zip_postal_code = $7, country = $8
WHERE id = $9
`

type UpdateUserParams struct {
	FullName      string `json:"full_name"`
	Phone         string `json:"phone"`
	AddressLine1  string `json:"address_line_1"`
	AddressLine2  string `json:"address_line_2"`
	City          string `json:"city"`
	StateProvince string `json:"state_province"`
	ZipPostalCode string `json:"zip_postal_code"`
	Country       string `json:"country"`
	ID            string `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateUser,
		arg.FullName,
		arg.Phone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.StateProvince,
		arg.ZipPostalCode,
		arg.Country,
		arg.ID,
	)
}

const updateUserFullNmae = `-- name: UpdateUserFullNmae :execrows
UPDATE users
SET full_name = $1
WHERE id = $2
`

type UpdateUserFullNmaeParams struct {
	FullName string `json:"full_name"`
	ID       string `json:"id"`
}

func (q *Queries) UpdateUserFullNmae(ctx context.Context, arg UpdateUserFullNmaeParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateUserFullNmae, arg.FullName, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
