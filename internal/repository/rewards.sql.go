// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rewards.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deductRewardAmount = `-- name: DeductRewardAmount :execrows
UPDATE rewards
SET available_amount = available_amount - 1
WHERE id = $1 AND available_amount > 0
`

func (q *Queries) DeductRewardAmount(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deductRewardAmount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAllRewards = `-- name: GetAllRewards :many
SELECT id,title,description,cost,available_amount,image_url,created_date FROM rewards
WHERE available_amount > 0
`

type GetAllRewardsRow struct {
	ID              int32       `json:"id"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	Cost            int32       `json:"cost"`
	AvailableAmount int32       `json:"available_amount"`
	ImageUrl        pgtype.Text `json:"image_url"`
	CreatedDate     time.Time   `json:"created_date"`
}

func (q *Queries) GetAllRewards(ctx context.Context) ([]GetAllRewardsRow, error) {
	rows, err := q.db.Query(ctx, getAllRewards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRewardsRow
	for rows.Next() {
		var i GetAllRewardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Cost,
			&i.AvailableAmount,
			&i.ImageUrl,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserRedeemdRewards = `-- name: GetAllUserRedeemdRewards :many
SELECT rr.id,rr.reward_id,rr.user_id,rr.redeemed_at,rr.cost as redeemed_cost,r.title,r.description,r.image_url,r.coupon_code FROM redeemed_rewards rr
LEFT JOIN rewards r
ON r.id = rr.reward_id
WHERE rr.user_id = $1
`

type GetAllUserRedeemdRewardsRow struct {
	ID           int32       `json:"id"`
	RewardID     int32       `json:"reward_id"`
	UserID       string      `json:"user_id"`
	RedeemedAt   time.Time   `json:"redeemed_at"`
	RedeemedCost int32       `json:"redeemed_cost"`
	Title        pgtype.Text `json:"title"`
	Description  pgtype.Text `json:"description"`
	ImageUrl     pgtype.Text `json:"image_url"`
	CouponCode   pgtype.Text `json:"coupon_code"`
}

func (q *Queries) GetAllUserRedeemdRewards(ctx context.Context, userID string) ([]GetAllUserRedeemdRewardsRow, error) {
	rows, err := q.db.Query(ctx, getAllUserRedeemdRewards, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserRedeemdRewardsRow
	for rows.Next() {
		var i GetAllUserRedeemdRewardsRow
		if err := rows.Scan(
			&i.ID,
			&i.RewardID,
			&i.UserID,
			&i.RedeemedAt,
			&i.RedeemedCost,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.CouponCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedeemedRewardByID = `-- name: GetRedeemedRewardByID :one
SELECT rr.id, reward_id, user_id, redeemed_at, rr.cost, r.id, title, description, r.cost, available_amount, image_url, created_date, coupon_code FROM redeemed_rewards rr
JOIN rewards r
ON r.id = rr.reward_id
WHERE rr.id = $1
`

type GetRedeemedRewardByIDRow struct {
	ID              int32       `json:"id"`
	RewardID        int32       `json:"reward_id"`
	UserID          string      `json:"user_id"`
	RedeemedAt      time.Time   `json:"redeemed_at"`
	Cost            int32       `json:"cost"`
	ID_2            int32       `json:"id_2"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	Cost_2          int32       `json:"cost_2"`
	AvailableAmount int32       `json:"available_amount"`
	ImageUrl        pgtype.Text `json:"image_url"`
	CreatedDate     time.Time   `json:"created_date"`
	CouponCode      string      `json:"coupon_code"`
}

func (q *Queries) GetRedeemedRewardByID(ctx context.Context, id int32) (GetRedeemedRewardByIDRow, error) {
	row := q.db.QueryRow(ctx, getRedeemedRewardByID, id)
	var i GetRedeemedRewardByIDRow
	err := row.Scan(
		&i.ID,
		&i.RewardID,
		&i.UserID,
		&i.RedeemedAt,
		&i.Cost,
		&i.ID_2,
		&i.Title,
		&i.Description,
		&i.Cost_2,
		&i.AvailableAmount,
		&i.ImageUrl,
		&i.CreatedDate,
		&i.CouponCode,
	)
	return i, err
}

const getRewardByID = `-- name: GetRewardByID :one
SELECT id, title, description, cost, available_amount, image_url, created_date, coupon_code FROM rewards
WHERE id = $1
`

func (q *Queries) GetRewardByID(ctx context.Context, id int32) (Reward, error) {
	row := q.db.QueryRow(ctx, getRewardByID, id)
	var i Reward
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Cost,
		&i.AvailableAmount,
		&i.ImageUrl,
		&i.CreatedDate,
		&i.CouponCode,
	)
	return i, err
}

const insertRedeemedReward = `-- name: InsertRedeemedReward :one
WITH inserted AS (
    INSERT INTO redeemed_rewards (reward_id, user_id, redeemed_at, cost)
    SELECT
        $1,
        $2,
        NOW(),
        r.cost
    FROM rewards r
    JOIN users u ON u.id = $2
    WHERE r.id = $1 AND u.token_balance > 0
    RETURNING reward_id
)
SELECT r.coupon_code
FROM inserted i
JOIN rewards r ON r.id = i.reward_id
`

type InsertRedeemedRewardParams struct {
	RewardID int32  `json:"reward_id"`
	UserID   string `json:"user_id"`
}

func (q *Queries) InsertRedeemedReward(ctx context.Context, arg InsertRedeemedRewardParams) (string, error) {
	row := q.db.QueryRow(ctx, insertRedeemedReward, arg.RewardID, arg.UserID)
	var coupon_code string
	err := row.Scan(&coupon_code)
	return coupon_code, err
}
